/*
 * Copyright 2018 Con Kolivas <kernel@kolivas.org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option)
 * any later version.  See COPYING for more details.
 */

#include <stdlib.h>
#include <assert.h>
#include <fcntl.h>
#include <limits.h>
#include <unistd.h>
#include <stdbool.h>

#include "logging.h"
#include "miner.h"
#include "util.h"

#include "dragonmint_t1.h"
#include "dm_temp_ctrl.h"

#define MUL_COEF 1.248

int opt_diff=0;

static const uint32_t difficult_Tbl[24] = {
	0x1d00ffff,// 1
	0x1d007fff,// 2
	0x1d005fff,// 3
	0x1d003fff,// 4
	0x1d001fff,// 8
	0x1d000fff,// 16
	0x1d0007ff,// 32
	0x1d0006ff,// 37
	0x1d0005ff,// 43
	0x1d0004ff,// 52
	0x1d0003ff,// 65
	0x1d0002ff,// 86
	0x1d00027f,// 103
	0x1d0001ff,// 129
	0x1c00ffff,// 256
	0x1c007fff,// 512
	0x1b3fffff,// 1024
	0x1b1fffff,// 2048
	0x1b0fffff,// 4096
	0x1b07ffff,// 8192
	0x1b03ffff,// 16384
	0x1b01ffff,// 32768
	0x1b00ffff,// 65536
	0x1b007fff,// 131072
};

const struct PLL_Clock PLL_Clk_12Mhz[T1_PLL_LV_NUM] = {
    {  0, 120 , T1_PLL(1, 80 , 3)},
    {  1, 121 , T1_PLL(1, 81 , 3)},
    {  2, 123 , T1_PLL(1, 82 , 3)},
    {  3, 124 , T1_PLL(1, 83 , 3)},
    {  4, 126 , T1_PLL(1, 84 , 3)},
    {  5, 127 , T1_PLL(1, 85 , 3)},
    {  6, 129 , T1_PLL(1, 86 , 3)},
    {  7, 130 , T1_PLL(1, 87 , 3)},
    {  8, 132 , T1_PLL(1, 88 , 3)},
    {  9, 133 , T1_PLL(1, 89 , 3)},
    { 10, 135 , T1_PLL(1, 90 , 3)},
    { 11, 136 , T1_PLL(1, 91 , 3)},
    { 12, 138 , T1_PLL(1, 92 , 3)},
    { 13, 139 , T1_PLL(1, 93 , 3)},
    { 14, 141 , T1_PLL(1, 94 , 3)},
    { 15, 142 , T1_PLL(1, 95 , 3)},
    { 16, 144 , T1_PLL(1, 96 , 3)},
    { 17, 145 , T1_PLL(1, 97 , 3)},
    { 18, 147 , T1_PLL(1, 98 , 3)},
    { 19, 148 , T1_PLL(1, 99 , 3)},
    { 20, 150 , T1_PLL(1, 50 , 2)},
    { 21, 153 , T1_PLL(1, 51 , 2)},
    { 22, 156 , T1_PLL(1, 52 , 2)},
    { 23, 159 , T1_PLL(1, 53 , 2)},
    { 24, 162 , T1_PLL(1, 54 , 2)},
    { 25, 165 , T1_PLL(1, 55 , 2)},
    { 26, 168 , T1_PLL(1, 56 , 2)},
    { 27, 171 , T1_PLL(1, 57 , 2)},
    { 28, 174 , T1_PLL(1, 58 , 2)},
    { 29, 177 , T1_PLL(1, 59 , 2)},
    { 30, 180 , T1_PLL(1, 60 , 2)},
    { 31, 183 , T1_PLL(1, 61 , 2)},
    { 32, 186 , T1_PLL(1, 62 , 2)},
    { 33, 189 , T1_PLL(1, 63 , 2)},
    { 34, 192 , T1_PLL(1, 64 , 2)},
    { 35, 195 , T1_PLL(1, 65 , 2)},
    { 36, 198 , T1_PLL(1, 66 , 2)},
    { 37, 201 , T1_PLL(1, 67 , 2)},
    { 38, 204 , T1_PLL(1, 68 , 2)},
    { 39, 207 , T1_PLL(1, 69 , 2)},
    { 40, 210 , T1_PLL(1, 70 , 2)},
    { 41, 213 , T1_PLL(1, 71 , 2)},
    { 42, 216 , T1_PLL(1, 72 , 2)},
    { 43, 219 , T1_PLL(1, 73 , 2)},
    { 44, 222 , T1_PLL(1, 74 , 2)},
    { 45, 225 , T1_PLL(1, 75 , 2)},
    { 46, 228 , T1_PLL(1, 76 , 2)},
    { 47, 231 , T1_PLL(1, 77 , 2)},
    { 48, 234 , T1_PLL(1, 78 , 2)},
    { 49, 237 , T1_PLL(1, 79 , 2)},
    { 50, 240 , T1_PLL(2, 160, 2)},
    { 51, 241 , T1_PLL(2, 161, 2)},
    { 52, 243 , T1_PLL(2, 162, 2)},
    { 53, 244 , T1_PLL(2, 163, 2)},
    { 54, 246 , T1_PLL(2, 164, 2)},
    { 55, 247 , T1_PLL(2, 165, 2)},
    { 56, 249 , T1_PLL(2, 166, 2)},
    { 57, 250 , T1_PLL(2, 167, 2)},
    { 58, 252 , T1_PLL(2, 168, 2)},
    { 59, 253 , T1_PLL(2, 169, 2)},
    { 60, 255 , T1_PLL(2, 170, 2)},
    { 61, 256 , T1_PLL(2, 171, 2)},
    { 62, 258 , T1_PLL(2, 172, 2)},
    { 63, 259 , T1_PLL(2, 173, 2)},
    { 64, 261 , T1_PLL(2, 174, 2)},
    { 65, 262 , T1_PLL(2, 175, 2)},
    { 66, 264 , T1_PLL(2, 176, 2)},
    { 67, 265 , T1_PLL(2, 177, 2)},
    { 68, 267 , T1_PLL(2, 178, 2)},
    { 69, 268 , T1_PLL(2, 179, 2)},
    { 70, 270 , T1_PLL(2, 180, 2)},
    { 71, 271 , T1_PLL(2, 181, 2)},
    { 72, 273 , T1_PLL(2, 182, 2)},
    { 73, 274 , T1_PLL(2, 183, 2)},
    { 74, 276 , T1_PLL(2, 184, 2)},
    { 75, 277 , T1_PLL(2, 185, 2)},
    { 76, 279 , T1_PLL(2, 186, 2)},
    { 77, 280 , T1_PLL(2, 187, 2)},
    { 78, 282 , T1_PLL(2, 188, 2)},
    { 79, 283 , T1_PLL(2, 189, 2)},
    { 80, 285 , T1_PLL(2, 190, 2)},
    { 81, 286 , T1_PLL(2, 191, 2)},
    { 82, 288 , T1_PLL(2, 192, 2)},
    { 83, 289 , T1_PLL(2, 193, 2)},
    { 84, 291 , T1_PLL(2, 194, 2)},
    { 85, 292 , T1_PLL(2, 195, 2)},
    { 86, 294 , T1_PLL(2, 196, 2)},
    { 87, 295 , T1_PLL(2, 197, 2)},
    { 88, 297 , T1_PLL(2, 198, 2)},
    { 89, 298 , T1_PLL(2, 199, 2)},
    { 90, 300 , T1_PLL(2, 100, 1)},
    { 91, 303 , T1_PLL(2, 101, 1)},
    { 92, 306 , T1_PLL(2, 102, 1)},
    { 93, 309 , T1_PLL(2, 103, 1)},
    { 94, 312 , T1_PLL(2, 104, 1)},
    { 95, 315 , T1_PLL(2, 105, 1)},
    { 96, 318 , T1_PLL(2, 106, 1)},
    { 97, 321 , T1_PLL(2, 107, 1)},
    { 98, 324 , T1_PLL(2, 108, 1)},
    { 99, 327 , T1_PLL(2, 109, 1)},
    {100, 330 , T1_PLL(2, 110, 1)},
    {101, 333 , T1_PLL(2, 111, 1)},
    {102, 336 , T1_PLL(2, 112, 1)},
    {103, 339 , T1_PLL(2, 113, 1)},
    {104, 342 , T1_PLL(2, 114, 1)},
    {105, 345 , T1_PLL(2, 115, 1)},
    {106, 348 , T1_PLL(2, 116, 1)},
    {107, 351 , T1_PLL(2, 117, 1)},
    {108, 354 , T1_PLL(2, 118, 1)},
    {109, 357 , T1_PLL(2, 119, 1)},
    {110, 360 , T1_PLL(2, 120, 1)},
    {111, 363 , T1_PLL(2, 121, 1)},
    {112, 366 , T1_PLL(2, 122, 1)},
    {113, 369 , T1_PLL(2, 123, 1)},
    {114, 372 , T1_PLL(2, 124, 1)},
    {115, 375 , T1_PLL(2, 125, 1)},
    {116, 378 , T1_PLL(2, 126, 1)},
    {117, 381 , T1_PLL(2, 127, 1)},
    {118, 384 , T1_PLL(2, 128, 1)},
    {119, 387 , T1_PLL(2, 129, 1)},
    {120, 390 , T1_PLL(2, 130, 1)},
    {121, 393 , T1_PLL(2, 131, 1)},
    {122, 396 , T1_PLL(2, 132, 1)},
    {123, 399 , T1_PLL(2, 133, 1)},
    {124, 402 , T1_PLL(2, 134, 1)},
    {125, 405 , T1_PLL(2, 135, 1)},
    {126, 408 , T1_PLL(2, 136, 1)},
    {127, 411 , T1_PLL(2, 137, 1)},
    {128, 414 , T1_PLL(2, 138, 1)},
    {129, 417 , T1_PLL(2, 139, 1)},
    {130, 420 , T1_PLL(2, 140, 1)},
    {131, 423 , T1_PLL(2, 141, 1)},
    {132, 426 , T1_PLL(2, 142, 1)},
    {133, 429 , T1_PLL(2, 143, 1)},
    {134, 432 , T1_PLL(2, 144, 1)},
    {135, 435 , T1_PLL(2, 145, 1)},
    {136, 438 , T1_PLL(2, 146, 1)},
    {137, 441 , T1_PLL(2, 147, 1)},
    {138, 444 , T1_PLL(2, 148, 1)},
    {139, 447 , T1_PLL(2, 149, 1)},
    {140, 450 , T1_PLL(2, 150, 1)},
    {141, 453 , T1_PLL(2, 151, 1)},
    {142, 456 , T1_PLL(2, 152, 1)},
    {143, 459 , T1_PLL(2, 153, 1)},
    {144, 462 , T1_PLL(2, 154, 1)},
    {145, 465 , T1_PLL(2, 155, 1)},
    {146, 468 , T1_PLL(2, 156, 1)},
    {147, 471 , T1_PLL(2, 157, 1)},
    {148, 474 , T1_PLL(2, 158, 1)},
    {149, 477 , T1_PLL(2, 159, 1)},
    {150, 480 , T1_PLL(2, 160, 1)},
    {151, 483 , T1_PLL(2, 161, 1)},
    {152, 486 , T1_PLL(2, 162, 1)},
    {153, 489 , T1_PLL(2, 163, 1)},
    {154, 492 , T1_PLL(2, 164, 1)},
    {155, 495 , T1_PLL(2, 165, 1)},
    {156, 498 , T1_PLL(2, 166, 1)},
    {157, 501 , T1_PLL(2, 167, 1)},
    {158, 504 , T1_PLL(2, 168, 1)},
    {159, 507 , T1_PLL(2, 169, 1)},
    {160, 510 , T1_PLL(2, 170, 1)},
    {161, 513 , T1_PLL(2, 171, 1)},
    {162, 516 , T1_PLL(2, 172, 1)},
    {163, 519 , T1_PLL(2, 173, 1)},
    {164, 522 , T1_PLL(2, 174, 1)},
    {165, 525 , T1_PLL(2, 175, 1)},
    {166, 528 , T1_PLL(2, 176, 1)},
    {167, 531 , T1_PLL(2, 177, 1)},
    {168, 534 , T1_PLL(2, 178, 1)},
    {169, 537 , T1_PLL(2, 179, 1)},
    {170, 540 , T1_PLL(2, 180, 1)},
    {171, 543 , T1_PLL(2, 181, 1)},
    {172, 546 , T1_PLL(2, 182, 1)},
    {173, 549 , T1_PLL(2, 183, 1)},
    {174, 552 , T1_PLL(2, 184, 1)},
    {175, 555 , T1_PLL(2, 185, 1)},
    {176, 558 , T1_PLL(2, 186, 1)},
    {177, 561 , T1_PLL(2, 187, 1)},
    {178, 564 , T1_PLL(2, 188, 1)},
    {179, 567 , T1_PLL(2, 189, 1)},
    {180, 570 , T1_PLL(2, 190, 1)},
    {181, 573 , T1_PLL(2, 191, 1)},
    {182, 576 , T1_PLL(2, 192, 1)},
    {183, 579 , T1_PLL(2, 193, 1)},
    {184, 582 , T1_PLL(2, 194, 1)},
    {185, 585 , T1_PLL(2, 195, 1)},
    {186, 588 , T1_PLL(2, 196, 1)},
    {187, 591 , T1_PLL(2, 197, 1)},
    {188, 594 , T1_PLL(2, 198, 1)},
    {189, 597 , T1_PLL(2, 199, 1)},
    {190, 600 , T1_PLL(2, 100, 0)},
    {191, 606 , T1_PLL(2, 101, 0)},
    {192, 612 , T1_PLL(2, 102, 0)},
    {193, 618 , T1_PLL(2, 103, 0)},
    {194, 624 , T1_PLL(2, 104, 0)},
    {195, 630 , T1_PLL(2, 105, 0)},
    {196, 636 , T1_PLL(2, 106, 0)},
    {197, 642 , T1_PLL(2, 107, 0)},
    {198, 648 , T1_PLL(2, 108, 0)},
    {199, 654 , T1_PLL(2, 109, 0)},
    {200, 660 , T1_PLL(2, 110, 0)},
    {201, 666 , T1_PLL(2, 111, 0)},
    {202, 672 , T1_PLL(2, 112, 0)},
    {203, 678 , T1_PLL(2, 113, 0)},
    {204, 684 , T1_PLL(2, 114, 0)},
    {205, 690 , T1_PLL(2, 115, 0)},
    {206, 696 , T1_PLL(2, 116, 0)},
    {207, 702 , T1_PLL(2, 117, 0)},
    {208, 708 , T1_PLL(2, 118, 0)},
    {209, 714 , T1_PLL(2, 119, 0)},
    {210, 720 , T1_PLL(2, 120, 0)},
    {211, 726 , T1_PLL(2, 121, 0)},
    {212, 732 , T1_PLL(2, 122, 0)},
    {213, 738 , T1_PLL(2, 123, 0)},
    {214, 744 , T1_PLL(2, 124, 0)},
    {215, 750 , T1_PLL(2, 125, 0)},
    {216, 756 , T1_PLL(2, 126, 0)},
    {217, 762 , T1_PLL(2, 127, 0)},
    {218, 768 , T1_PLL(2, 128, 0)},
    {219, 774 , T1_PLL(2, 129, 0)},
    {220, 780 , T1_PLL(2, 130, 0)},
    {221, 786 , T1_PLL(2, 131, 0)},
    {222, 792 , T1_PLL(2, 132, 0)},
    {223, 798 , T1_PLL(2, 133, 0)},
    {224, 804 , T1_PLL(2, 134, 0)},
    {225, 810 , T1_PLL(2, 135, 0)},
    {226, 816 , T1_PLL(2, 136, 0)},
    {227, 822 , T1_PLL(2, 137, 0)},
    {228, 828 , T1_PLL(2, 138, 0)},
    {229, 834 , T1_PLL(2, 139, 0)},
    {230, 840 , T1_PLL(2, 140, 0)},
    {231, 846 , T1_PLL(2, 141, 0)},
    {232, 852 , T1_PLL(2, 142, 0)},
    {233, 858 , T1_PLL(2, 143, 0)},
    {234, 864 , T1_PLL(2, 144, 0)},
    {235, 870 , T1_PLL(2, 145, 0)},
    {236, 876 , T1_PLL(2, 146, 0)},
    {237, 882 , T1_PLL(2, 147, 0)},
    {238, 888 , T1_PLL(2, 148, 0)},
    {239, 894 , T1_PLL(2, 149, 0)},
    {240, 900 , T1_PLL(2, 150, 0)},
    {241, 906 , T1_PLL(2, 151, 0)},
    {242, 912 , T1_PLL(2, 152, 0)},
    {243, 918 , T1_PLL(2, 153, 0)},
    {244, 924 , T1_PLL(2, 154, 0)},
    {245, 930 , T1_PLL(2, 155, 0)},
    {246, 936 , T1_PLL(2, 156, 0)},
    {247, 942 , T1_PLL(2, 157, 0)},
    {248, 948 , T1_PLL(2, 158, 0)},
    {249, 954 , T1_PLL(2, 159, 0)},
    {250, 960 , T1_PLL(2, 160, 0)},
    {251, 966 , T1_PLL(2, 161, 0)},
    {252, 972 , T1_PLL(2, 162, 0)},
    {253, 978 , T1_PLL(2, 163, 0)},
    {254, 984 , T1_PLL(2, 164, 0)},
    {255, 990 , T1_PLL(2, 165, 0)},
    {256, 996 , T1_PLL(2, 166, 0)},
    {257, 1002, T1_PLL(2, 167, 0)},
    {258, 1008, T1_PLL(2, 168, 0)},
    {259, 1014, T1_PLL(2, 169, 0)},
    {260, 1020, T1_PLL(2, 170, 0)},
    {261, 1026, T1_PLL(2, 171, 0)},
    {262, 1032, T1_PLL(2, 172, 0)},
    {263, 1038, T1_PLL(2, 173, 0)},
    {264, 1044, T1_PLL(2, 174, 0)},
    {265, 1050, T1_PLL(2, 175, 0)},
    {266, 1056, T1_PLL(2, 176, 0)},
    {267, 1062, T1_PLL(2, 177, 0)},
    {268, 1068, T1_PLL(2, 178, 0)},
    {269, 1074, T1_PLL(2, 179, 0)},
    {270, 1080, T1_PLL(2, 180, 0)},
    {271, 1086, T1_PLL(2, 181, 0)},
    {272, 1092, T1_PLL(2, 182, 0)},
    {273, 1098, T1_PLL(2, 183, 0)},
    {274, 1104, T1_PLL(2, 184, 0)},
    {275, 1110, T1_PLL(2, 185, 0)},
    {276, 1116, T1_PLL(2, 186, 0)},
    {277, 1122, T1_PLL(2, 187, 0)},
    {278, 1128, T1_PLL(2, 188, 0)},
    {279, 1134, T1_PLL(2, 189, 0)},
    {280, 1140, T1_PLL(2, 190, 0)},
    {281, 1146, T1_PLL(2, 191, 0)},
    {282, 1152, T1_PLL(2, 192, 0)},
    {283, 1158, T1_PLL(2, 193, 0)},
    {284, 1164, T1_PLL(2, 194, 0)},
    {285, 1170, T1_PLL(2, 195, 0)},
    {286, 1176, T1_PLL(2, 196, 0)},
    {287, 1182, T1_PLL(2, 197, 0)},
    {288, 1188, T1_PLL(2, 198, 0)},
    {289, 1194, T1_PLL(2, 199, 0)},
    {290, 1200, T1_PLL(1, 100, 0)},
    {291, 1212, T1_PLL(1, 101, 0)},
    {292, 1224, T1_PLL(1, 102, 0)},
    {293, 1236, T1_PLL(1, 103, 0)},
    {294, 1248, T1_PLL(1, 104, 0)},
    {295, 1260, T1_PLL(1, 105, 0)},
    {296, 1272, T1_PLL(1, 106, 0)},
    {297, 1284, T1_PLL(1, 107, 0)},
    {298, 1296, T1_PLL(1, 108, 0)},
    {299, 1308, T1_PLL(1, 109, 0)},
    {300, 1320, T1_PLL(1, 110, 0)},
    {301, 1332, T1_PLL(1, 111, 0)},
    {302, 1344, T1_PLL(1, 112, 0)},
    {303, 1356, T1_PLL(1, 113, 0)},
    {304, 1368, T1_PLL(1, 114, 0)},
    {305, 1380, T1_PLL(1, 115, 0)},
    {306, 1392, T1_PLL(1, 116, 0)},
    {307, 1404, T1_PLL(1, 117, 0)},
    {308, 1416, T1_PLL(1, 118, 0)},
    {309, 1428, T1_PLL(1, 119, 0)},
    {310, 1440, T1_PLL(1, 120, 0)},
    {311, 1452, T1_PLL(1, 121, 0)},
    {312, 1464, T1_PLL(1, 122, 0)},
    {313, 1476, T1_PLL(1, 123, 0)},
    {314, 1488, T1_PLL(1, 124, 0)},
    {315, 1500, T1_PLL(1, 125, 0)},
    {316, 1512, T1_PLL(1, 126, 0)},
    {317, 1524, T1_PLL(1, 127, 0)},
    {318, 1536, T1_PLL(1, 128, 0)},
    {319, 1548, T1_PLL(1, 129, 0)},
    {320, 1560, T1_PLL(1, 130, 0)},
    {321, 1572, T1_PLL(1, 131, 0)},
    {322, 1584, T1_PLL(1, 132, 0)},
    {323, 1596, T1_PLL(1, 133, 0)},
};

const uint8_t default_reg[T1_PLL_LV_NUM][REG_LENGTH] =
{
	{0x02, 0x50, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 120MHz
	{0x02, 0x51, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 121MHz
	{0x02, 0x52, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 123MHz
	{0x02, 0x53, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 124MHz
	{0x02, 0x54, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 126MHz
	{0x02, 0x55, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 127MHz
	{0x02, 0x56, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 129MHz
	{0x02, 0x57, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 130MHz
	{0x02, 0x58, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 132MHz
	{0x02, 0x59, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 133MHz
	{0x02, 0x5a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 135MHz
	{0x02, 0x5b, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 136MHz
	{0x02, 0x5c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 138MHz
	{0x02, 0x5d, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 139MHz
	{0x02, 0x5e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 141MHz
	{0x02, 0x5f, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 142MHz
	{0x02, 0x60, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 144MHz
	{0x02, 0x61, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 145MHz
	{0x02, 0x62, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 147MHz
	{0x02, 0x63, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 148MHz
	{0x02, 0x32, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 150MHz
	{0x02, 0x33, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 153MHz
	{0x02, 0x34, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 156MHz
	{0x02, 0x35, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 159MHz
	{0x02, 0x36, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 162MHz
	{0x02, 0x37, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 165MHz
	{0x02, 0x38, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 168MHz
	{0x02, 0x39, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 171MHz
	{0x02, 0x3a, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 174MHz
	{0x02, 0x3b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 177MHz
	{0x02, 0x3c, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 180MHz
	{0x02, 0x3d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 183MHz
	{0x02, 0x3e, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 186MHz
	{0x02, 0x3f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 189MHz
	{0x02, 0x40, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 192MHz
	{0x02, 0x41, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 195MHz
	{0x02, 0x42, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 198MHz
	{0x02, 0x43, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 201MHz
	{0x02, 0x44, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 204MHz
	{0x02, 0x45, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 207MHz
	{0x02, 0x46, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 210MHz
	{0x02, 0x47, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 213MHz
	{0x02, 0x48, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 216MHz
	{0x02, 0x49, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 219MHz
	{0x02, 0x4a, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 222MHz
	{0x02, 0x4b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 225MHz
	{0x02, 0x4c, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 228MHz
	{0x02, 0x4d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 231MHz
	{0x02, 0x4e, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 234MHz
	{0x02, 0x4f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 237MHz
	{0x04, 0xa0, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 240MHz
	{0x04, 0xa1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 241MHz
	{0x04, 0xa2, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 243MHz
	{0x04, 0xa3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 244MHz
	{0x04, 0xa4, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 246MHz
	{0x04, 0xa5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 247MHz
	{0x04, 0xa6, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 249MHz
	{0x04, 0xa7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 250MHz
	{0x04, 0xa8, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 252MHz
	{0x04, 0xa9, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 253MHz
	{0x04, 0xaa, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 255MHz
	{0x04, 0xab, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 256MHz
	{0x04, 0xac, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 258MHz
	{0x04, 0xad, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 259MHz
	{0x04, 0xae, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 261MHz
	{0x04, 0xaf, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 262MHz
	{0x04, 0xb0, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 264MHz
	{0x04, 0xb1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 265MHz
	{0x04, 0xb2, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 267MHz
	{0x04, 0xb3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 268MHz
	{0x04, 0xb4, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 270MHz
	{0x04, 0xb5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 271MHz
	{0x04, 0xb6, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 273MHz
	{0x04, 0xb7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 274MHz
	{0x04, 0xb8, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 276MHz
	{0x04, 0xb9, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 277MHz
	{0x04, 0xba, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 279MHz
	{0x04, 0xbb, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 280MHz
	{0x04, 0xbc, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 282MHz
	{0x04, 0xbd, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 283MHz
	{0x04, 0xbe, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 285MHz
	{0x04, 0xbf, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 286MHz
	{0x04, 0xc0, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 288MHz
	{0x04, 0xc1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 289MHz
	{0x04, 0xc2, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 291MHz
	{0x04, 0xc3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 292MHz
	{0x04, 0xc4, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 294MHz
	{0x04, 0xc5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 295MHz
	{0x04, 0xc6, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 297MHz
	{0x04, 0xc7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 298MHz
	{0x04, 0x64, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 300MHz
	{0x04, 0x65, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 303MHz
	{0x04, 0x66, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 306MHz
	{0x04, 0x67, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 309MHz
	{0x04, 0x68, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 312MHz
	{0x04, 0x69, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 315MHz
	{0x04, 0x6a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 318MHz
	{0x04, 0x6b, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 321MHz
	{0x04, 0x6c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 324MHz
	{0x04, 0x6d, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 327MHz
	{0x04, 0x6e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 330MHz
	{0x04, 0x6f, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 333MHz
	{0x04, 0x70, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 336MHz
	{0x04, 0x71, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 339MHz
	{0x04, 0x72, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 342MHz
	{0x04, 0x73, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 345MHz
	{0x04, 0x74, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 348MHz
	{0x04, 0x75, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 351MHz
	{0x04, 0x76, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 354MHz
	{0x04, 0x77, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 357MHz
	{0x04, 0x78, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 360MHz
	{0x04, 0x79, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 363MHz
	{0x04, 0x7a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 366MHz
	{0x04, 0x7b, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 369MHz
	{0x04, 0x7c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 372MHz
	{0x04, 0x7d, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 375MHz
	{0x04, 0x7e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 378MHz
	{0x04, 0x7f, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 381MHz
	{0x04, 0x80, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 384MHz
	{0x04, 0x81, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 387MHz
	{0x04, 0x82, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 390MHz
	{0x04, 0x83, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 393MHz
	{0x04, 0x84, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 396MHz
	{0x04, 0x85, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 399MHz
	{0x04, 0x86, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 402MHz
	{0x04, 0x87, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 405MHz
	{0x04, 0x88, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 408MHz
	{0x04, 0x89, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 411MHz
	{0x04, 0x8a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 414MHz
	{0x04, 0x8b, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 417MHz
	{0x04, 0x8c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 420MHz
	{0x04, 0x8d, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 423MHz
	{0x04, 0x8e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 426MHz
	{0x04, 0x8f, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 429MHz
	{0x04, 0x90, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 432MHz
	{0x04, 0x91, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 435MHz
	{0x04, 0x92, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 438MHz
	{0x04, 0x93, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 441MHz
	{0x04, 0x94, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 444MHz
	{0x04, 0x95, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 447MHz
	{0x04, 0x96, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 450MHz
	{0x04, 0x97, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 453MHz
	{0x04, 0x98, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 456MHz
	{0x04, 0x99, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 459MHz
	{0x04, 0x9a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 462MHz
	{0x04, 0x9b, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 465MHz
	{0x04, 0x9c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 468MHz
	{0x04, 0x9d, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 471MHz
	{0x04, 0x9e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 474MHz
	{0x04, 0x9f, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 477MHz
	{0x04, 0xa0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 480MHz
	{0x04, 0xa1, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 483MHz
	{0x04, 0xa2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 486MHz
	{0x04, 0xa3, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 489MHz
	{0x04, 0xa4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 492MHz
	{0x04, 0xa5, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 495MHz
	{0x04, 0xa6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 498MHz
	{0x04, 0xa7, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 501MHz
	{0x04, 0xa8, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 504MHz
	{0x04, 0xa9, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 507MHz
	{0x04, 0xaa, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 510MHz
	{0x04, 0xab, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 513MHz
	{0x04, 0xac, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 516MHz
	{0x04, 0xad, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 519MHz
	{0x04, 0xae, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 522MHz
	{0x04, 0xaf, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 525MHz
	{0x04, 0xb0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 528MHz
	{0x04, 0xb1, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 531MHz
	{0x04, 0xb2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 534MHz
	{0x04, 0xb3, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 537MHz
	{0x04, 0xb4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 540MHz
	{0x04, 0xb5, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 543MHz
	{0x04, 0xb6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 546MHz
	{0x04, 0xb7, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00},	 // 549MHz
	{0x04, 0xb8, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 552MHz
	{0x04, 0xb9, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 555MHz
	{0x04, 0xba, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 558MHz
	{0x04, 0xbb, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 561MHz
	{0x04, 0xbc, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 564MHz
	{0x04, 0xbd, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 567MHz
	{0x04, 0xbe, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 570MHz
	{0x04, 0xbf, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 573MHz
	{0x04, 0xc0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 576MHz
	{0x04, 0xc1, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 579MHz
	{0x04, 0xc2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 582MHz
	{0x04, 0xc3, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 585MHz
	{0x04, 0xc4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 588MHz
	{0x04, 0xc5, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 591MHz
	{0x04, 0xc6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 594MHz
	{0x04, 0xc7, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 597MHz
	{0x04, 0x64, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 600MHz
	{0x04, 0x65, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 606MHz
	{0x04, 0x66, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 612MHz
	{0x04, 0x67, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 618MHz
	{0x04, 0x68, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 624MHz
	{0x04, 0x69, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 630MHz
	{0x04, 0x6a, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 636MHz
	{0x04, 0x6b, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 642MHz
	{0x04, 0x6c, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 648MHz
	{0x04, 0x6d, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 654MHz
	{0x04, 0x6e, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 660MHz
	{0x04, 0x6f, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 666MHz
	{0x04, 0x70, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 672MHz
	{0x04, 0x71, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 678MHz
	{0x04, 0x72, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 684MHz
	{0x04, 0x73, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 690MHz
	{0x04, 0x74, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 696MHz
	{0x04, 0x75, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 702MHz
	{0x04, 0x76, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 708MHz
	{0x04, 0x77, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 714MHz
	{0x04, 0x78, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 720MHz
	{0x04, 0x79, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 726MHz
	{0x04, 0x7a, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 732MHz
	{0x04, 0x7b, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 738MHz
	{0x04, 0x7c, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 744MHz
	{0x04, 0x7d, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 750MHz
	{0x04, 0x7e, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 756MHz
	{0x04, 0x7f, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 762MHz
	{0x04, 0x80, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 768MHz
	{0x04, 0x81, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 774MHz
	{0x04, 0x82, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 780MHz
	{0x04, 0x83, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 786MHz
	{0x04, 0x84, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 792MHz
	{0x04, 0x85, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 798MHz
	{0x04, 0x86, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 804MHz
	{0x04, 0x87, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 810MHz
	{0x04, 0x88, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 816MHz
	{0x04, 0x89, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 822MHz
	{0x04, 0x8a, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 828MHz
	{0x04, 0x8b, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 834MHz
	{0x04, 0x8c, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 840MHz
	{0x04, 0x8d, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 846MHz
	{0x04, 0x8e, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 852MHz
	{0x04, 0x8f, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 858MHz
	{0x04, 0x90, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 864MHz
	{0x04, 0x91, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 870MHz
	{0x04, 0x92, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 876MHz
	{0x04, 0x93, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 882MHz
	{0x04, 0x94, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 888MHz
	{0x04, 0x95, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 894MHz
	{0x04, 0x96, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 900MHz
	{0x04, 0x97, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 906MHz
	{0x04, 0x98, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 912MHz
	{0x04, 0x99, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 918MHz
	{0x04, 0x9a, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 924MHz
	{0x04, 0x9b, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 930MHz
	{0x04, 0x9c, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 936MHz
	{0x04, 0x9d, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 942MHz
	{0x04, 0x9e, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 948MHz
	{0x04, 0x9f, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 954MHz
	{0x04, 0xa0, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 960MHz
	{0x04, 0xa1, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 966MHz
	{0x04, 0xa2, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 972MHz
	{0x04, 0xa3, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 978MHz
	{0x04, 0xa4, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 984MHz
	{0x04, 0xa5, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 990MHz
	{0x04, 0xa6, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 996MHz
	{0x04, 0xa7, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1002MHz
	{0x04, 0xa8, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1008MHz
	{0x04, 0xa9, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1014MHz
	{0x04, 0xaa, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1020MHz
	{0x04, 0xab, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1026MHz
	{0x04, 0xac, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1032MHz
	{0x04, 0xad, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1038MHz
	{0x04, 0xae, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1044MHz
	{0x04, 0xaf, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1050MHz
	{0x04, 0xb0, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1056MHz
	{0x04, 0xb1, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1062MHz
	{0x04, 0xb2, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1068MHz
	{0x04, 0xb3, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1074MHz
	{0x04, 0xb4, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1080MHz
	{0x04, 0xb5, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1086MHz
	{0x04, 0xb6, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1092MHz
	{0x04, 0xb7, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1098MHz
	{0x04, 0xb8, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1104MHz
	{0x04, 0xb9, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1110MHz
	{0x04, 0xba, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1116MHz
	{0x04, 0xbb, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1122MHz
	{0x04, 0xbc, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1128MHz
	{0x04, 0xbd, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1134MHz
	{0x04, 0xbe, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1140MHz
	{0x04, 0xbf, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1146MHz
	{0x04, 0xc0, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1152MHz
	{0x04, 0xc1, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1158MHz
	{0x04, 0xc2, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1164MHz
	{0x04, 0xc3, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1170MHz
	{0x04, 0xc4, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1176MHz
	{0x04, 0xc5, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1182MHz
	{0x04, 0xc6, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1188MHz
	{0x04, 0xc7, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1194MHz
	{0x02, 0x64, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1200MHz
	{0x02, 0x65, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1212MHz
	{0x02, 0x66, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1224MHz
	{0x02, 0x67, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1236MHz
	{0x02, 0x68, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1248MHz
	{0x02, 0x69, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1260MHz
	{0x02, 0x6a, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1272MHz
	{0x02, 0x6b, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1284MHz
	{0x02, 0x6c, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1296MHz
	{0x02, 0x6d, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1308MHz
	{0x02, 0x6e, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1320MHz
	{0x02, 0x6f, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1332MHz
	{0x02, 0x70, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1344MHz
	{0x02, 0x71, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1356MHz
	{0x02, 0x72, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1368MHz
	{0x02, 0x73, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1380MHz
	{0x02, 0x74, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1392MHz
	{0x02, 0x75, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1404MHz
	{0x02, 0x76, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1416MHz
	{0x02, 0x77, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1428MHz
	{0x02, 0x78, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1440MHz
	{0x02, 0x79, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1452MHz
	{0x02, 0x7a, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1464MHz
	{0x02, 0x7b, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1476MHz
	{0x02, 0x7c, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1488MHz
	{0x02, 0x7d, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1500MHz
	{0x02, 0x7e, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1512MHz
	{0x02, 0x7f, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1524MHz
	{0x02, 0x80, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1536MHz
	{0x02, 0x81, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1548MHz
	{0x02, 0x82, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1560MHz
	{0x02, 0x83, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1572MHz
	{0x02, 0x84, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1584MHz
	{0x02, 0x85, 0x40, 0x02, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x20, 0x00, 0x00},	 // 1596MHz
};

extern struct T1_chain *chain[MAX_CHAIN_NUM];
extern uint8_t chain_mask;
extern hardware_version_e g_hwver;
//int chain_voltage_flag[MAX_CHAIN_NUM];

#if 0
const unsigned short wCRCTalbeAbs[] =
{
	0x0000, 0xCC01, 0xD801, 0x1400,
	0xF001, 0x3C00, 0x2800, 0xE401,
	0xA001, 0x6C00, 0x7800, 0xB401,
	0x5000, 0x9C01, 0x8801, 0x4400,
};

unsigned short CRC16_2(unsigned char* pchMsg, unsigned short wDataLen)
{
	volatile unsigned short wCRC = 0xFFFF;
	unsigned short i;
	unsigned char chChar;

	for (i = 0; i < wDataLen; i++)
	{
		chChar = *pchMsg++;
		wCRC = wCRCTalbeAbs[(chChar ^ wCRC) & 15] ^ (wCRC >> 4);
		wCRC = wCRCTalbeAbs[((chChar >> 4) ^ wCRC) & 15] ^ (wCRC >> 4);
	}

	return wCRC;
}
#endif

static void applog_hexdump(char *prefix, uint8_t *buff, int len, int level)
{
	static char line[512];
	char *pos = line;
	int i;
	if (len < 1)
	{
		return;
	}

	pos += sprintf(pos, "%s: %d bytes:", prefix, len);
	for (i = 0; i < len; i++)
	{
		if (i > 0 && (i % 32) == 0)
		{
			applog(LOG_INFO, "%s", line);
			pos = line;
			pos += sprintf(pos, "\t");
		}
		pos += sprintf(pos, "%.2X ", buff[i]);
	}
	applog(level, "%s", line);
}

void hexdump(char *prefix, uint8_t *buff, int len)
{
	applog_hexdump(prefix, buff, len, LOG_WARNING);
}

void hexdump_error(char *prefix, uint8_t *buff, int len)
{
	applog_hexdump(prefix, buff, len, LOG_ERR);
}

bool dm_cmd_resetall(uint8_t chain_id, uint8_t chip_id, uint8_t *result)
{
    uint8_t cmd[2] = {0x0, 0x0};

    return mcompat_cmd_reset(chain_id, chip_id, cmd, result);
}

bool dm_cmd_resetjob(uint8_t chain_id, uint8_t chip_id, uint8_t *result)
{
    uint8_t cmd[2] = {0xed, 0xed};

    return mcompat_cmd_reset(chain_id, chip_id, cmd, result);
}

bool dm_cmd_resetbist(uint8_t chain_id, uint8_t chip_id, uint8_t *result)
{
    uint8_t cmd[2] = {0x20, 0x20};

    return mcompat_cmd_reset(chain_id, chip_id, cmd, result);
}

int T1_ConfigT1PLLClock(uint32_t optPll)
{
	int i;
	int T1Pll = 0;

	if (optPll > 0) {
		if (optPll <= PLL_Clk_12Mhz[0].speedMHz) {
			T1Pll = 0; //found
		} else {
			for (i = 1; i < T1_PLL_LV_NUM; i++) {
				if (optPll < PLL_Clk_12Mhz[i].speedMHz
					&& optPll >= PLL_Clk_12Mhz[i-1].speedMHz) {
					T1Pll = i - 1; //found
					break;
				}
			}
		}
	}

	return T1Pll;
}

bool T1_SetT1PLLClock(struct T1_chain *t1, int pllClkIdx, int chip_id)
{
	uint8_t temp_reg[REG_LENGTH];
	int cid = t1->chain_id;

	memcpy(temp_reg, default_reg[pllClkIdx], REG_LENGTH);

	if (!mcompat_cmd_write_register(cid, chip_id, temp_reg, REG_LENGTH)) {
		applog(LOG_WARNING, "Failed to set PLL Lv.%d on T1 %d in T1_SetT1PLLClock", pllClkIdx, cid);
		return false;
	}
	if (chip_id) {
		applog(LOG_NOTICE, "T1 %d chip %d PLL set to %d %d MHz", cid, chip_id,
		       pllClkIdx, PLL_Clk_12Mhz[pllClkIdx].speedMHz);
	} else {
		applog(LOG_NOTICE, "T1 %d PLL set to %d %d MHz", cid,
		       pllClkIdx, PLL_Clk_12Mhz[pllClkIdx].speedMHz);
		t1->pll = pllClkIdx;
	}

	return true;
}

uint8_t *create_job(uint8_t chip_id, uint8_t job_id, struct work *work)
{
	double sdiff = work->device_diff;
	uint8_t tmp_buf[JOB_LENGTH];
	uint16_t crc;
	uint8_t i;

	static uint8_t job[JOB_LENGTH] = {
		/* command */
		0x00, 0x00,
		/* midstate3 */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/* midstate2 */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/* midstate1 */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/* midstate0 */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/* wdata */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		/* start nonce */
		0x00, 0x00, 0x00, 0x00,
		/* difficulty 1 */
		0xff, 0xff, 0x00, 0x1d,
		/* end nonce */
		0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00,
		/* crc data */
		0x00, 0x00, 0x00, 0x00
	};

	uint32_t *p1 = (uint32_t *) &job[130];
	uint32_t *p2 = (uint32_t *) (work->data + 64);
	uint32_t diffIdx;
	//uint32_t diffIdx,*diff=(uint32_t*)&job[50];	//difficulty pointer

	job[0] = (job_id << 4) | CMD_WRITE_JOB_T1;		// fixed by duanhao
	job[1] = chip_id;

	swab256(job + 2, work->midstate3);
	swab256(job + 34, work->midstate2);
	swab256(job + 66, work->midstate1);
	swab256(job + 98, work->midstate);
	p1 = (uint32_t *) &job[130];
	p2 = (uint32_t *) (work->data + 64);
	p1[0] = bswap_32(p2[0]);
	p1[1] = bswap_32(p2[1]);
	p1[2] = bswap_32(p2[2]);

	uint8_t diff[4] = {0x1e, 0x03, 0xff, 0xff};

	if (sdiff>131072)
		memcpy(diff, &(difficult_Tbl[23]), 4);
	else if (sdiff>65536)
		memcpy(diff, &(difficult_Tbl[22]), 4);
	else if (sdiff>32767)
		memcpy(diff, &(difficult_Tbl[21]), 4);
	else if (sdiff>16383)
		memcpy(diff, &(difficult_Tbl[20]), 4);
	else if (sdiff>8191)
		memcpy(diff, &(difficult_Tbl[19]), 4);
	else if (sdiff>4095)
		memcpy(diff, &(difficult_Tbl[18]), 4);
	else if (sdiff>2047)
		memcpy(diff, &(difficult_Tbl[17]), 4);
	else if (sdiff>1023)
		memcpy(diff, &(difficult_Tbl[16]), 4);
	else if (sdiff > 511)
		memcpy(diff, &(difficult_Tbl[15]), 4);
	else if (sdiff > 255)
		memcpy(diff, &(difficult_Tbl[14]), 4);
	else {
		if (opt_diff>=1&&opt_diff<=17)
		{
			diffIdx=opt_diff-1;
			memcpy(diff, &(difficult_Tbl[diffIdx]), 4);
		}
		else
			memcpy(diff, &(difficult_Tbl[13]), 4);
	}

	memcpy(job+146, diff, 4);

	memset(tmp_buf, 0, sizeof(tmp_buf));
	for(i = 0; i < 79; i++)
	{
		tmp_buf[(2 * i) + 1] = job[(2 * i) + 0];
		tmp_buf[(2 * i) + 0] = job[(2 * i) + 1];
	}
	crc = CRC16_2(tmp_buf, 158);
	job[158] = (uint8_t)((crc >> 8) & 0xff);
	job[159] = (uint8_t)((crc >> 0) & 0xff);

	//applog(LOG_NOTICE, "[create job] %d \r", sdiff);
	//hexdump("job:", job, JOB_LENGTH);

	return job;
}




#define COOLDOWN_MS (30 * 1000)
#define DISABLE_CHIP_FAIL_THRESHOLD 3
#define LEAST_CORE_ONE_CHAIN 603
#define RESET_CHAIN_CNT 2



/********** disable / re-enable related section (temporary for testing) */
int get_current_ms(void)
{
	cgtimer_t ct;
	cgtimer_time(&ct);
	return cgtimer_to_ms(&ct);
}

bool is_chip_disabled(struct T1_chain *t1, uint8_t chip_id)
{
	struct T1_chip *chip = &t1->chips[chip_id - 1];
	return chip->disabled || chip->cooldown_begin != 0;
}

/* check and disable chip, remember time */
void disable_chip(struct T1_chain *t1, uint8_t chip_id)
{
//    flush_spi(t1);
	struct T1_chip *chip = &t1->chips[chip_id - 1];
	int cid = t1->chain_id;
	if (is_chip_disabled(t1, chip_id)) {
		applog(LOG_WARNING, "%d: chip %d already disabled",
		       cid, chip_id);
		return;
	}
	applog(LOG_WARNING, "%d: temporary disabling chip %d", cid, chip_id);
	chip->cooldown_begin = get_current_ms();
}

bool set_work(struct T1_chain *t1, uint8_t chip_id, struct work *work, uint8_t queue_states)
{
	int cid = t1->chain_id;
	struct T1_chip *chip = &t1->chips[chip_id - 1];
	bool retval = false;

	int job_id = chip->last_queued_id + 1;

	//if (chip_id==1) applog(LOG_INFO, "%d: queuing chip %d with job_id %d, state=0x%02x", cid, chip_id, job_id, queue_states);
	//applog(LOG_INFO, "%d: queuing chip %d with job_id %d, state=0x%02x", cid, chip_id, job_id, queue_states);
	if (job_id == (queue_states & 0x0f) || job_id == (queue_states >> 4))
	{
		applog(LOG_WARNING, "%d: job overlap: %d, 0x%02x", cid, job_id, queue_states);
	}

	if (chip->work[chip->last_queued_id] != NULL)
	{
		free_work(chip->work[chip->last_queued_id]);
		retval = true;
	}
	uint8_t *jobdata = create_job(chip_id, job_id, work);
	if (!mcompat_cmd_write_job(cid, chip_id, jobdata, JOB_LENGTH))
	{
		/* give back work */
		free_work(work);
		applog(LOG_ERR, "%d: failed to set work for chip %d.%d", cid, chip_id, job_id);
		disable_chip(t1, chip_id);
	}
	else
	{
		chip->work[chip->last_queued_id] = work;
		chip->last_queued_id++;
		chip->last_queued_id &= 3;
	}
	/*
	 * if (chip_id == 10)
	 * {
	 * cgtime(&tvCurr);
	 * timersub(&tvCurr, &tvLast, &tvDiff);
	 * applog(LOG_NOTICE, "CCCCCCCTime.tv_sec:%d,tv_usec:%d.", tvDiff.tv_sec,tvDiff.tv_usec);
	 * cgtime(&tvLast);
	}
	*/
	return retval;
}

bool get_nonce(struct T1_chain *t1, uint8_t *nonce, uint8_t *chip_id, uint8_t *job_id, uint8_t *micro_job_id)
{
	uint8_t buffer[10];

	memset(buffer, 0, sizeof(buffer));

#ifdef USE_AUTONONCE
	if (mcompat_cmd_read_nonce(t1->chain_id, buffer, NONCE_LEN))
#else
	if (mcompat_cmd_read_result(t1->chain_id, CMD_ADDR_BROADCAST, buffer, NONCE_LEN))
#endif
	{
		*job_id = buffer[0] >> 4;
		*chip_id = buffer[1];
		*(uint16_t *)micro_job_id = buffer[3];
		memcpy(nonce, buffer + 4, 4);

		applog(LOG_INFO, "Got nonce for chain%d / chip%d / nonce 0x%08x",
			t1->chain_id, *chip_id, *(uint32_t*)nonce);

		return true;
	}

	return false;
}

bool check_chip(struct T1_chain *t1, int i)
{
	uint8_t buffer[REG_LENGTH] = {0};
	int cid = t1->chain_id;
	int chip_id = i + 1;

	if (!mcompat_cmd_read_register(cid, chip_id, buffer, REG_LENGTH)) {
		applog(LOG_WARNING, "%d: Failed to read register for "
				"chip %d -> disabling", cid, chip_id);
		t1->chips[i].num_cores = 0;
		t1->chips[i].disabled = true;
		return false;
	} else {
		//hexdump("check chip:", buffer, REG_LENGTH);
	}

	t1->chips[i].num_cores = buffer[11];
	t1->num_cores += t1->chips[i].num_cores;
	//applog(LOG_WARNING, "%d: Found chip %d with %d active cores",
	//  cid, chip_id, t1->chips[i].num_cores);

	memcpy(t1->chips[i].reg, buffer, REG_LENGTH);
	t1->chips[i].temp= mcompat_temp_to_centigrade(0x000003ff & ((buffer[7] << 8) | buffer[8]));

	if (t1->chips[i].num_cores < BROKEN_CHIP_THRESHOLD) {
		applog(LOG_WARNING, "%d: broken chip %d with %d active "
		"cores (threshold = %d)", cid, chip_id,
		       t1->chips[i].num_cores, BROKEN_CHIP_THRESHOLD);

		t1->chips[i].disabled = true;
		t1->num_cores -= t1->chips[i].num_cores;

		return false;
	}

	if (t1->chips[i].num_cores < WEAK_CHIP_THRESHOLD) {
		applog(LOG_WARNING, "%d: weak chip %d with %d active "
		"cores (threshold = %d)", cid,
		       chip_id, t1->chips[i].num_cores, WEAK_CHIP_THRESHOLD);

		return false;
	}

	/* Reenable this in case we have cycled through this function more than
	 * once. */
	t1->chips[i].disabled = false;
	return true;
}

int dragonmint_get_voltage_stats(struct T1_chain *t1, dragonmint_reg_ctrl_t *s_reg_ctrl)
{
	int i = 0;
	int cid = t1->chain_id;
	s_reg_ctrl->highest_vol[cid] = s_reg_ctrl->stat_val[cid][0];
	s_reg_ctrl->lowest_vol[cid] = s_reg_ctrl->stat_val[cid][0];
	int total_vol = 0;
	int cnt = 0;

	if ((t1->num_active_chips < 1) || (t1 == NULL))
		return -1;

	for (i = 0; i < t1->num_active_chips; i++) {
		if (s_reg_ctrl->highest_vol[cid] < s_reg_ctrl->stat_val[cid][i])
			s_reg_ctrl->highest_vol[cid] = s_reg_ctrl->stat_val[cid][i];

		if (s_reg_ctrl->lowest_vol[cid] > s_reg_ctrl->stat_val[cid][i])
			s_reg_ctrl->lowest_vol[cid] = s_reg_ctrl->stat_val[cid][i];

		// Ignore voltage value 0
		if (s_reg_ctrl->stat_val[cid][i] > 0) {
			total_vol += s_reg_ctrl->stat_val[cid][i];
			cnt++;
		}
	}

	// Ignore max and min voltages
	if (cnt > 2) {
		s_reg_ctrl->average_vol[cid] =
			(total_vol - s_reg_ctrl->highest_vol[cid] - s_reg_ctrl->lowest_vol[cid]) / (cnt - 2);
	} else
		s_reg_ctrl->average_vol[cid] = 0;

	return 0;
}

bool dragonmint_check_voltage(struct T1_chain *t1, int chip_id, dragonmint_reg_ctrl_t *s_reg_ctrl)
{
	uint32_t rd[3], rd_min = 0xFFFFFFFF, rd_max = 0, rd_v = 0;
	int cid = t1->chain_id, i;
	float tmp_v;
	uint8_t reg[REG_LENGTH] = {0};

	/* Oversample by reading voltage 3 times and choosing middle value */
	for (i = 0; i < 3; i++) {
		if (unlikely(!mcompat_cmd_read_register(cid, chip_id, reg, REG_LENGTH))) {
			applog(LOG_NOTICE, "%d: Failed to read register for ""chip %d -> disabling",
			       cid, chip_id);
			t1->chips[chip_id - 1].num_cores = 0;
			t1->chips[chip_id - 1].disabled = 1;
			return false;
		}
		rd[i] = 0x000003ff & ((reg[7] << 8) | reg[8]);
		if (rd[i] < rd_min)
			rd_min = rd[i];
		if (rd[i] > rd_max)
			rd_max = rd[i];
	}
	rd_v = rd_min;
	for (i = 0; i < 3; i++) {
		if (rd[i] > rd_v && rd[i] < rd_max)
			rd_v = rd[i];
	}

	/* update temp database */
	tmp_v = (float)(rd_v * MUL_COEF) / 1024;
	t1->chips[chip_id - 1].nVol = tmp_v * 1000;
	s_reg_ctrl->stat_val[t1->chain_id][chip_id-1] = t1->chips[chip_id-1].nVol;
	//applog(LOG_NOTICE, "[Read VOL %s:%d]rd_v = %d, tmp_v = %f",__FUNCTION__,__LINE__,rd_v,tmp_v);

	return true;
}

hardware_version_e dragonmint_get_hwver(void)
{
	FILE* fd;
	char buffer[8] = {0};
	hardware_version_e version;

	fd = fopen(DRAGONMINT_HARDWARE_VERSION_FILE, "r");
	if (fd == NULL) {
		applog(LOG_ERR, "Open hwver file failed, assuming hardware version G19 !");
		return HARDWARE_VERSION_G19;
	}

	FREAD(buffer, 8, 1, fd);
	fclose(fd);

	if (strstr(buffer, "G9") != NULL) {
		version = HARDWARE_VERSION_G9;
		applog(LOG_INFO, "hardware version is G9");
	}else if (strstr(buffer, "G19") != 0) {
		version = HARDWARE_VERSION_G19;
		applog(LOG_INFO, "hardware version is G19");
	}else {
		version = 0;
		applog(LOG_ERR, "unknown hardware version !!!");
	}

	return version;
}

uint32_t dragonmint_get_chipnum(void)
{
	FILE* fd;
	char buffer[8] = {0};

	fd = fopen(DRAGONMINT_CHIP_NUM_FILE, "r");
	if (fd == NULL) {
		applog(LOG_ERR, "Failed to read chip number from %s, assuming chip number %d!", 
			DRAGONMINT_CHIP_NUM_FILE, MAX_CHIP_NUM);
		return MAX_CHIP_NUM;
	}

	FREAD(buffer, 8, 1, fd);
	fclose(fd);

	uint32_t chipnum = atoi(buffer);
	if (chipnum > 0 && chipnum <= MAX_CHIP_NUM)
		return chipnum;
	else
		return MAX_CHIP_NUM;
}

#if 0
dragonmint_type_e dragonmint_get_miner_type(void)
{
	FILE* fd;
	char buffer[64] = {0};
	dragonmint_type_e miner_type;

	fd = fopen(DRAGONMINT_MINER_TYPE_FILE, "r");
	if (fd == NULL) {
		applog(LOG_ERR, "Open type file failed, assuming miner type T1 !");
		return DRAGONMINT_TYPE_T1;
	}

	FREAD(buffer, 8, 1, fd);
	fclose(fd);

	if (strstr(buffer, "T1") != NULL) {
		miner_type = DRAGONMINT_TYPE_T1;
		applog(LOG_INFO, "miner type is T1");
	}else if (strstr(buffer, "T2") != NULL) {
		miner_type = DRAGONMINT_TYPE_A6;
		applog(LOG_INFO, "miner type is T2");
	}else if (strstr(buffer, "T3") != NULL) {
		miner_type = DRAGONMINT_TYPE_A7;
		applog(LOG_INFO, "miner type is T3");
	}else if (strstr(buffer, "T4") != NULL) {
		miner_type = DRAGONMINT_TYPE_A8;
		applog(LOG_INFO, "miner type is T4");
	}else {
		miner_type = 0;
		applog(LOG_INFO, "unknown miner type !!!");
	}

	return miner_type;
}
#endif

extern struct T1_chain *chain[MAX_CHAIN_NUM];
void chain_all_exit(void)
{
	int i;
	applog(LOG_NOTICE, "All chain power off and spi exit!");

	for(i = 0; i < MAX_CHAIN_NUM; i++)
	{
		if (chain[i] == NULL)
			continue;
		free(chain[i]->chips);
		mcompat_set_led(i, LED_ON);
		mcompat_set_power_en(i, 0);
		//asic_gpio_write(chain[i]->spi_ctx->led, 1);
		//asic_gpio_write(chain[i]->spi_ctx->power_en, 0);
		chain[i]->chips = NULL;
		//chain[i]->spi_ctx = NULL;
		free(chain[i]);
	}
}

int dragonmint_chain_power_down(struct T1_chain *t1)
{
	mcompat_set_power_en(t1->chain_id, 0);
	mcompat_set_start_en(t1->chain_id, 0);
	mcompat_set_led(t1->chain_id, LED_OFF);
	return 0;
}

extern int chain_flag[MAX_CHAIN_NUM];
extern int chain_plug[MAX_CHAIN_NUM];
void power_down_all_chain(void)
{
	int i;

	for(i = 0; i < MAX_CHAIN_NUM; i++)
	{
		if (chain_flag[i] != 1){
			continue;
		}
		dragonmint_chain_power_down(chain[i]);
	}
}

void write_miner_ageing_status(uint32_t statusCode)
{
	FILE* fd;

	fd = fopen(MINER_AGEING_STATUS_FILE, "w+");
	if (fd == NULL) {
		applog(LOG_ERR, "Create miner ageing status file failed!");
		return;
	}
	rewind(fd);
	fprintf(fd, "%d", statusCode);
	applog(LOG_INFO, "Miner ageing status is %d!", statusCode);
	fclose(fd);

	return;
}

bool t1_set_pll(struct T1_chain *t1, int chip_id, int target_pll)
{
	int i, start_pll = t1->pll;
	uint8_t reg[REG_LENGTH] = {0};

	if (target_pll > start_pll) {
		// increase pll step by step
		for (i = start_pll; i <= target_pll; i++) {
			memcpy(reg, default_reg[i], REG_LENGTH);
			if (!T1_SetT1PLLClock(t1, i, chip_id)) {
				applog(LOG_WARNING, "set default PLL fail");
				write_miner_ageing_status(AGEING_CONFIG_PLL_FAILED);
				return false;
			}
			if (chip_id == CMD_ADDR_BROADCAST)
				t1->pll = i;
			// update temperature for all chains once every second
			dm_tempctrl_update_temp(chain_mask);
		}
	} else if (target_pll < start_pll) {
		// decrease pll step by step
		for (i = start_pll; i >= target_pll; i--) {
			memcpy(reg, default_reg[i], REG_LENGTH);
			if (!T1_SetT1PLLClock(t1, i, chip_id)) {
				applog(LOG_WARNING, "set default PLL fail");
				write_miner_ageing_status(AGEING_CONFIG_PLL_FAILED);
				return false;
			}
			if (chip_id == CMD_ADDR_BROADCAST)
				t1->pll = i;
			// update temperature for all chains once every second
			dm_tempctrl_update_temp(chain_mask);
		}
	}

	/* re-config adc div cause the pll is changed */
	mcompat_cfg_tsadc_divider(t1->chain_id, PLL_Clk_12Mhz[t1->pll].speedMHz);

	return true;
}
